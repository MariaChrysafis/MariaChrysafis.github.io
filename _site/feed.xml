<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-11-29T18:57:32-08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Puzzles</title><subtitle>Puzzles of all sorts...related to math, computer science, and other musings!
</subtitle><author><name>Maria Chrysafis</name><email>maria.chrysafis.junior@gmail.com</email></author><entry><title type="html">Treaps</title><link href="http://localhost:4000/2022/11/07/p2.html" rel="alternate" type="text/html" title="Treaps" /><published>2022-11-07T00:00:00-08:00</published><updated>2022-11-07T00:00:00-08:00</updated><id>http://localhost:4000/2022/11/07/p2</id><content type="html" xml:base="http://localhost:4000/2022/11/07/p2.html"><![CDATA[<p>In a <strong>treap</strong>, each node has two values:</p>
<ul>
  <li>A a random <code class="language-plaintext highlighter-rouge">priority</code>.</li>
  <li>A <code class="language-plaintext highlighter-rouge">value</code>.</li>
</ul>

<p>The values in a treap satisfy the binary search property, and the priorities in a treap satisfy the min-heap property.</p>

<p>There are two simple, yet powerful, operations treaps can do: splitting and merging.</p>
<ul>
  <li>For any value $x$, you can split a treap into two treaps: one with keys $\le x$ and another with keys $&gt; x$.</li>
  <li>If all keys in one treap are strictly smaller than all keys in another treap, then we can merge those two treaps.</li>
</ul>

<p>The worst case time complexity for both of these operations is $\mathcal{O}(N)$, but on average, they run in $\mathcal{O}(\log N)$, making them extremely fast in practice.</p>

<h1 id="splitting">Splitting</h1>
<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
<span class="n">pair</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">*</span><span class="p">,</span> <span class="n">Node</span><span class="o">*&gt;</span> <span class="n">split</span> <span class="p">(</span><span class="n">Node</span><span class="o">*</span> <span class="n">node</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="c1">//&lt;= x and &gt;= x</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">make_pair</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">nullptr</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">right</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">;</span>
        <span class="n">update</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">make_pair</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">make_pair</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">left</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
        <span class="n">update</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">make_pair</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">first</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h1 id="merging">Merging</h1>

<h1 id="uses">Uses</h1>
<h2 id="reversal">Reversal</h2>
<h2 id="range-updates">Range Updates</h2>
<h2 id="cut-and-paste">Cut and Paste</h2>

<div class="lineComment">
Like this
</div>]]></content><author><name>Maria Chrysafis</name><email>maria.chrysafis.junior@gmail.com</email></author><summary type="html"><![CDATA[In a treap, each node has two values: A a random priority. A value.]]></summary></entry><entry><title type="html">Binary Search Trees</title><link href="http://localhost:4000/2022/11/06/p1.html" rel="alternate" type="text/html" title="Binary Search Trees" /><published>2022-11-06T00:00:00-07:00</published><updated>2022-11-06T00:00:00-07:00</updated><id>http://localhost:4000/2022/11/06/p1</id><content type="html" xml:base="http://localhost:4000/2022/11/06/p1.html"><![CDATA[<p>Binary search trees are nothing more than <em>special</em> binary trees that satisfy what’s called the <strong>binary search tree property</strong>:</p>
<ul>
  <li>The keys in a node’s <strong>left</strong> subtree is strictly <strong>smaller</strong> than the key of the node itself.</li>
  <li>The keys in a node’s <strong>right</strong> subtree is strictly <strong>larger</strong> than the key of the node itself.</li>
</ul>

<p>Perhaps at first, this may seem like a rather arbitrary definition. But indeed, it proves quite useful.</p>
<h3 id="adding-a-node">Adding a Node</h3>

<h3 id="adding-a-node-complexity">Adding a Node Complexity</h3>
<p>Suppose we build a BST from a random permutation. Let $q(n)$ be the average number of nodes on the path from the root down to an arbitrary node in the BST.</p>

<div class="claim">
$q(n) \le 2 \cdot H_n$, where $H_n$ is the $n$th Harmonic number.
</div>
<div class="proof">
\begin{align}
q(n) &amp;= 1 + \frac{1}{n^2} \sum_{x = 1}^n \left( \sum_{r = 1}^{x - 1} q(x - 1) + \sum_{r = x + 1}^n q(n - x) \right) \newline
&amp;= 1 + \frac{1}{n^2} \sum_{x = 1}^n q(x - 1) \cdot (x - 1) + q(n - x) \cdot (n - x) \newline
&amp;=  1 + \frac{2}{n^2} \sum_{x = 1}^{n - 1} q(x) \cdot x
\end{align}
With a recurrence relation for $q$ under our belt, the next natural step is to bound $q$.

We will now prove using the method of mathematical induction that $q_n \le 2 \cdot H_n$. We can verify the base case, when $n = 1$, quite easily because $q_1 = 1 \le 2 \cdot H_1 = 2$. As for the inductive step:
\begin{align}
q(n) &amp;= 1 + \frac{2}{n^2} \sum_{x = 1}^{n - 1} q(x) \cdot x \newline
&amp;\le 1 + \frac{2}{n^2} \sum_{x = 1}^{n - 1} 2 x H_x \newline
&amp;= 1 + \frac{4}{n^2} \sum_{x = 1}^{n - 1} x \sum_{i = 1}^{x} \frac{1}{i} \newline
&amp;= 1 + \frac{4}{n^2} \sum_{i = 1}^{n - 1} \sum_{x = i}^{n - 1} \frac{x}{i} \newline
&amp;= 1 + \frac{4}{n^2} \sum_{i = 1}^{n - 1} \frac{1}{i} \sum_{x = i}^{n - 1} x \newline
&amp;= 1 + \frac{4}{n^2} \sum_{i = 1}^{n - 1} \frac{1}{i} \left( \binom{n}{2} - \binom{i}{2} \right) \newline
&amp;= 1 + \frac{4}{n^2} \binom{n}{2} H_{n - 1} - \frac{4}{n^2}\sum_{i = 1}^{n - 1} \frac{1}{i} \binom{i}{2} \newline
&amp;= 1 + \frac{2 (n - 1)}{n} H_{n - 1} - \sum_{i = 1}^{n - 1} \frac{i - 1}{2} \newline
&amp;= 1 + 2H_{n - 1} - \frac{2}{n} H_{n - 1} - \frac{2\binom{n - 1}{2}}{n^2} \newline
&amp;= 1 + 2H_{n - 1} - \frac{2}{n} H_{n - 1} - \frac{n - 1}{n} \newline
&amp;= \frac{1}{n} + 2H_{n - 1} - \frac{2}{n} H_{n - 1} \newline
&amp;\le 2H_n,
\end{align}
from which it follows that indeed $q(n) \le 2 \cdot H_n$ by induction.
</div>

<h3 id="removing-a-node">Removing a Node</h3>

<h3 id="sample-problem-kth-smallest-element-in-bst">Sample Problem: Kth Smallest Element in BST</h3>
<p>See <a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/"> this LeetCode problem for the problem statement.</a></p>

<h3 id="finding-the-kth-smallest-element">Finding the kth smallest element</h3>
<p>It turns out that we can recursively find the $k$th smallest key (0-indexed) in our binary search tree in $\mathcal{O}(\text{depth})$, if we know the size of the subtrees at each node. To do so, consider the following algorithm:</p>
<ul>
  <li>Initialize our current node <code class="language-plaintext highlighter-rouge">cur</code> to be the tree’s root.</li>
  <li>If the subtree size of the left child of <code class="language-plaintext highlighter-rouge">cur</code> is less than $k$, then we know that the $k$th smallest element lies in the left subtree of <code class="language-plaintext highlighter-rouge">cur</code>, so we can recurse to <code class="language-plaintext highlighter-rouge">cur = cur.left</code>.</li>
  <li>If the subtree size of the left child of <code class="language-plaintext highlighter-rouge">cur</code> is equal to $k$, then we know that our current node has the $k$th smallest key. Return <code class="language-plaintext highlighter-rouge">cur</code>.</li>
  <li>If the subtree size of the right child of <code class="language-plaintext highlighter-rouge">cur</code> is greater than $k$, then we know that the $k$th smallest element is in the right subtree of <code class="language-plaintext highlighter-rouge">cur</code>. Thus, we can recursive to <code class="language-plaintext highlighter-rouge">cur = cur.right</code> and set $k = k - 1$ - <code class="language-plaintext highlighter-rouge">cur.right.size</code>.</li>
</ul>

<h3 id="problems">Problems</h3>
<ul>
  <li><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/">Kth Smallest Element in a BST</a></li>
  <li></li>
</ul>]]></content><author><name>Maria Chrysafis</name><email>maria.chrysafis.junior@gmail.com</email></author><summary type="html"><![CDATA[Binary search trees are nothing more than special binary trees that satisfy what’s called the binary search tree property: The keys in a node’s left subtree is strictly smaller than the key of the node itself. The keys in a node’s right subtree is strictly larger than the key of the node itself.]]></summary></entry></feed>