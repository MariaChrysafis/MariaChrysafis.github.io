<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-11-24T15:57:37-08:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Puzzles</title><subtitle>Puzzles of all sorts...related to math, computer science, and other musings!
</subtitle><author><name>Maria Chrysafis</name><email>maria.chrysafis.junior@gmail.com</email></author><entry><title type="html">Treaps</title><link href="http://localhost:4000/2022/11/06/p1.html" rel="alternate" type="text/html" title="Treaps" /><published>2022-11-06T00:00:00-07:00</published><updated>2022-11-06T00:00:00-07:00</updated><id>http://localhost:4000/2022/11/06/p1</id><content type="html" xml:base="http://localhost:4000/2022/11/06/p1.html"><![CDATA[<p>Treaps are an extremely powerful and perhaps underrated data structure. But before delving into what a treap can do, it is worth looking at binary search trees–arguably one of the simplest data structures.</p>
<h2 id="binary-search-trees">Binary Search Trees</h2>
<p>Binary search trees are nothing more than <em>special</em> binary trees that satisfy what’s called the <strong>binary search tree property</strong>:</p>
<ul>
  <li>The keys in a node’s <strong>left</strong> subtree is strictly <strong>smaller</strong> than the key of the node itself.</li>
  <li>The keys in a node’s <strong>right</strong> subtree is strictly <strong>larger</strong> than the key of the node itself.</li>
</ul>

<p>Perhaps at first, this may seem like a rather arbitrary definition. But indeed, it proves quite useful.</p>
<h3 id="adding-a-node">Adding a Node</h3>
<h3 id="adding-a-node-complexity">Adding a Node Complexity</h3>
<p>Suppose we build a BST from a random permutation. Let $q(n)$ be the average number of nodes on the path from the root down to an arbitrary node in the BST.</p>

<div class="claim">
$q(n) \le 2 \cdot H_n$, where $H_n$ is the $n$th Harmonic number.
</div>

<div class="proof">
\begin{align}
q(n) &amp;= 1 + \frac{1}{n^2} \sum_{x = 1}^n \left( \sum_{r = 1}^{x - 1} q(x - 1) + \sum_{r = x + 1}^n q(n - x) \right) \newline
&amp;= 1 + \frac{1}{n^2} \sum_{x = 1}^n q(x - 1) \cdot (x - 1) + q(n - x) \cdot (n - x) \newline
&amp;=  1 + \frac{2}{n^2} \sum_{x = 1}^{n - 1} q(x) \cdot x
\end{align}
There we have a recurrence relation.
</div>

<h4 id="more">More</h4>

<h3 id="finding-the-kth-element">Finding the kth Element</h3>
<p>It turns out that we can recursively find the $k$th smallest key (0-indexed) in our binary search tree in $\mathcal{O}(\text{depth})$, if we know the size of the subtrees at each node. To do so, consider the following algorithm:</p>
<ul>
  <li>Initialize our current node <code class="language-plaintext highlighter-rouge">cur</code> to be the tree’s root.</li>
  <li>If the subtree size of the left child of <code class="language-plaintext highlighter-rouge">cur</code> is less than $k$, then we know that the $k$th smallest element lies in the left subtree of <code class="language-plaintext highlighter-rouge">cur</code>, so we can recurse to <code class="language-plaintext highlighter-rouge">cur = cur.left</code>.</li>
  <li>If the subtree size of the left child of <code class="language-plaintext highlighter-rouge">cur</code> is equal to $k$, then we know that our current node has the $k$th smallest key. Return <code class="language-plaintext highlighter-rouge">cur</code>.</li>
  <li>If the subtree size of the right child of <code class="language-plaintext highlighter-rouge">cur</code> is greater than $k$, then we know that the $k$th smallest element is in the right subtree of <code class="language-plaintext highlighter-rouge">cur</code>. Thus, we can recursive to <code class="language-plaintext highlighter-rouge">cur = cur.right</code> and set $k = k - 1$ - <code class="language-plaintext highlighter-rouge">cur.right.size</code>.</li>
</ul>]]></content><author><name>Maria Chrysafis</name><email>maria.chrysafis.junior@gmail.com</email></author><summary type="html"><![CDATA[Treaps are an extremely powerful and perhaps underrated data structure. But before delving into what a treap can do, it is worth looking at binary search trees–arguably one of the simplest data structures. Binary Search Trees Binary search trees are nothing more than special binary trees that satisfy what’s called the binary search tree property: The keys in a node’s left subtree is strictly smaller than the key of the node itself. The keys in a node’s right subtree is strictly larger than the key of the node itself.]]></summary></entry></feed>