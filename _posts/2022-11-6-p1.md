---
layout: post
title: Binary Search Trees
classes: wide
comments: true
---
Binary search trees are nothing more than *special* binary trees that satisfy what's called the **binary search tree property**:
- The keys in a node's **left** subtree is strictly **smaller** than the key of the node itself.
- The keys in a node's **right** subtree is strictly **larger** than the key of the node itself.

Perhaps at first, this may seem like a rather arbitrary definition. But indeed, it proves quite useful. 
### Adding a Node

### Adding a Node Complexity
Suppose we build a BST from a random permutation. Let $q(n)$ be the average number of nodes on the path from the root down to an arbitrary node in the BST.

<div class="claim">
$q(n) \le 2 \cdot H_n$, where $H_n$ is the $n$th Harmonic number.
</div>
<div class="proof">
\begin{align}
q(n) &= 1 + \frac{1}{n^2} \sum_{x = 1}^n \left( \sum_{r = 1}^{x - 1} q(x - 1) + \sum_{r = x + 1}^n q(n - x) \right) \newline
&= 1 + \frac{1}{n^2} \sum_{x = 1}^n q(x - 1) \cdot (x - 1) + q(n - x) \cdot (n - x) \newline
&=  1 + \frac{2}{n^2} \sum_{x = 1}^{n - 1} q(x) \cdot x
\end{align}
With a recurrence relation for $q$ under our belt, the next natural step is to bound $q$.

We will now prove using the method of mathematical induction that $q_n \le 2 \cdot H_n$. We can verify the base case, when $n = 1$, quite easily because $q_1 = 1 \le 2 \cdot H_1 = 2$. As for the inductive step:
\begin{align}
q(n) &= 1 + \frac{2}{n^2} \sum_{x = 1}^{n - 1} q(x) \cdot x \newline
&\le 1 + \frac{2}{n^2} \sum_{x = 1}^{n - 1} 2 x H_x \newline
&= 1 + \frac{4}{n^2} \sum_{x = 1}^{n - 1} x \sum_{i = 1}^{x} \frac{1}{i} \newline
&= 1 + \frac{4}{n^2} \sum_{i = 1}^{n - 1} \sum_{x = i}^{n - 1} \frac{x}{i} \newline
&= 1 + \frac{4}{n^2} \sum_{i = 1}^{n - 1} \frac{1}{i} \sum_{x = i}^{n - 1} x \newline
&= 1 + \frac{4}{n^2} \sum_{i = 1}^{n - 1} \frac{1}{i} \left( \binom{n}{2} - \binom{i}{2} \right) \newline
&= 1 + \frac{4}{n^2} \binom{n}{2} H_{n - 1} - \frac{4}{n^2}\sum_{i = 1}^{n - 1} \frac{1}{i} \binom{i}{2} \newline
&= 1 + \frac{2 (n - 1)}{n} H_{n - 1} - \sum_{i = 1}^{n - 1} \frac{i - 1}{2} \newline
&= 1 + 2H_{n - 1} - \frac{2}{n} H_{n - 1} - \frac{2\binom{n - 1}{2}}{n^2} \newline
&= 1 + 2H_{n - 1} - \frac{2}{n} H_{n - 1} - \frac{n - 1}{n} \newline
&= \frac{1}{n} + 2H_{n - 1} - \frac{2}{n} H_{n - 1} \newline
&\le 2H_n,
\end{align}
from which it follows that indeed $q(n) \le 2 \cdot H_n$ by induction.
</div>

### Removing a Node 

### Sample Problem: Kth Smallest Element in BST
See <a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/"> this LeetCode problem for the problem statement.



### Finding the kth smallest element
It turns out that we can recursively find the $k$th smallest key (0-indexed) in our binary search tree in $\mathcal{O}(\text{depth})$, if we know the size of the subtrees at each node. To do so, consider the following algorithm:
- Initialize our current node `cur` to be the tree's root.
- If the subtree size of the left child of `cur` is less than $k$, then we know that the $k$th smallest element lies in the left subtree of `cur`, so we can recurse to `cur = cur.left`.
- If the subtree size of the left child of `cur` is equal to $k$, then we know that our current node has the $k$th smallest key. Return `cur`.
- If the subtree size of the right child of `cur` is greater than $k$, then we know that the $k$th smallest element is in the right subtree of `cur`. Thus, we can recursive to `cur = cur.right` and set $k = k - 1$ - `cur.right.size`. 

### Problems
- <a href = "https://leetcode.com/problems/kth-smallest-element-in-a-bst/">Kth Smallest Element in a BST</a>
- 

